package com.base.ExtendsEemo;
/*
* 继承extends关键字，可以让一个类与另一个类建立起父子关系。
* 特点：子类能继承父类的非私有成员（成员变量、成员方法）
* 继承后对象的创建
* 子类的对象是由子类，父类共同完成的。
* 好处：减少重复代码的编写。
*
* 权限修饰符:限制类中的成员能够访问的范围
* 修饰符|在本类中|同一个包下的其他类|任意包下的子类里|任意包下的任意类里
* private| yes | no | no | no |
* 缺省| yes | yes | no | no |
* protected| yes | yes | yes | no |
* public| yes | yes | yes | yes |
*
* Java是单继承，一个类只能继承一个直接父类，Java中的类不支持多继承（例如一个孩子只能有一个父亲），但是继承多层继承（子父祖）
* Object类是Java中所有类的祖宗
*
* 方法重写
* 当子类觉得父类中的某个方法不好用，或者无法满足自己的需求是，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类这个方法。
* 注意
* 重写后，方法的访问，Java会遵循就近原则
* 使用@Override注解，它可以指定Java编译器，检查我们方法重写的格式是否正确，代码可读性也会更好。
* 子类重写父类时，访问权限必须大于或者等于父类该方法的权限【public>protected>缺省】
* 重写的方法返回值类型，必须与重写方法的返回值类型一样，或者范围更小。
* 私有方法、静态方法不能被重写，如果重写会报错。
*
* 在子类方法中访问其他成员，是依照就近原则的
* 如果局部变量跟子类变量冲突可以通过this指向子类变量，想访问父类变量可以通过super关键字
*
* 子类构造器的特点
* 子类的全部构造器，都会先调用父类的构造器，在执行自己。
* 为什么呢？
* 默认情况下，子类的全部构造器的第一行代码都是super() 【写不写都有】,他会调用父类的无参构造器。
* 如果父类没有无参构造器，则必须在子类构造器第一行手写super(...),调用父类的有参数构造器
* 在任意类的构造器中，是可以通过this(...)调用该类的其他构造器的
* this(...)/super(...)都只能放在构造器的第一行，因此两者不能同时出现。
*
* */
public class ExtendsMain {
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.setName("小兰");
        t.setSkill("Java");
        t.getInfo();
        t.printInfo();
        Student s = new Student();
        s.test();
    }
}
